#!/usr/bin/env node
/* eslint-disable guard-for-in */
/* eslint-disable require-jsdoc */
/* eslint-disable no-unused-vars */

const args = require('args-parser')(process.argv);
const fs = require('fs');
const {exit} = require('process');
const figma = require('./figma');
const path = require('path');


if (args.help) {
  console.log('usage : pull-from-figma [--file=figma.json] [--ref=.*]');
  exit(0);
}

const vectorMap = {};
const vectorList = [];
const vectorTypes = ['VECTOR', 'LINE', 'REGULAR_POLYGON', 'ELLIPSE', 'STAR', 'COMPONENT'];

function preprocessTree(node) {
  let vectorsOnly = node.name.charAt(0) !== '#';
  let vectorVConstraint = null;
  let vectorHConstraint = null;

  function paintsRequireRender(paints) {
    if (!paints) return false;

    let numPaints = 0;
    for (const paint of paints) {
      if (paint.visible === false) continue;

      numPaints++;
      if (paint.type === 'EMOJI') return true;
    }

    return numPaints > 1;
  }

  if (paintsRequireRender(node.fills) ||
        paintsRequireRender(node.strokes) ||
        (node.blendMode != null && ['PASS_THROUGH', 'NORMAL'].indexOf(node.blendMode) < 0)) {
    node.type = 'VECTOR';
  }

  const children = node.children && node.children.filter((child) => child.visible !== false);
  if (children) {
    for (let j=0; j<children.length; j++) {
      if (vectorTypes.indexOf(children[j].type) < 0) vectorsOnly = false;
      else {
        if (vectorVConstraint != null && children[j].constraints.vertical != vectorVConstraint) vectorsOnly = false;
        if (vectorHConstraint != null && children[j].constraints.horizontal != vectorHConstraint) vectorsOnly = false;
        vectorVConstraint = children[j].constraints.vertical;
        vectorHConstraint = children[j].constraints.horizontal;
      }
    }
  }
  node.children = children;

  if (children && children.length > 0 && vectorsOnly) {
    node.type = 'VECTOR';
    node.constraints = {
      vertical: vectorVConstraint,
      horizontal: vectorHConstraint,
    };
  }
  if (vectorTypes.indexOf(node.type) >= 0) {
    node.type = 'VECTOR';
    vectorMap[node.id] = node;
    vectorList.push(node.id);
    node.children = [];
  }

  if (node.children) {
    for (const child of node.children) {
      preprocessTree(child);
    }
  }
}

async function pullFromFigma(fileKey, config) {
  const axios = require('axios').create({headers: {'X-Figma-Token': process.env.FIGMA_TOKEN}});


  const baseUrl = 'https://api.figma.com';
  let resp = await axios.get(`${baseUrl}/v1/files/${fileKey}`);
  const data = resp.data;

  const doc = data.document;
  const canvas = doc.children[0];
  const html = '';

  for (let i=0; i<canvas.children.length; i++) {
    const child = canvas.children[i];
    if (child.visible !== false) {
      const child = canvas.children[i];
      preprocessTree(child);
    }
  }

  const guids = vectorList.join(',');
  resp = await axios.get(`${baseUrl}/v1/images/${fileKey}?ids=${guids}&format=svg&svg_include_id=true`);
  const imageJSON = resp.data;
  const images = imageJSON.images || {};
  if (images) {
    let promises = [];
    const guids = [];
    for (const guid in images) {
      if (images[guid] == null) continue;
      guids.push(guid);
      promises.push(axios.get(images[guid]));
    }

    let responses = await Promise.all(promises);
    promises = [];
    for (const resp of responses) {
      promises.push(resp.data);
    }

    responses = await Promise.all(promises);
    for (let i=0; i<responses.length; i++) {
      images[guids[i]] = responses[i].replace('<svg ', '<svg preserveAspectRatio="none" ');
    }
  }

  const componentMap = {};
  let contents = `/**\n* This file is auto-generated by pull-from-figma. DO NOT EDIT.\n* run \`npx pull-from-figma --ref=${config.key}\` to update.\n* https://www.figma.com/file/${fileKey}\n*/\n\n`;
  contents+=`import React, { PureComponent } from 'react';\n\n`;
  let nextSection = '';

  for (let i=0; i<canvas.children.length; i++) {
    const child = canvas.children[i];
    if (child.visible !== false) {
      const child = canvas.children[i];
      const {name, code} = figma.createComponent(child, images, componentMap);

      nextSection += `/* Component ${name} */
      ${code}`;

      nextSection += `export class ${child.name.replace(/\W+/g, '')} extends PureComponent {\n`;
      nextSection += '  render() {\n';
      nextSection += `    return <div className="master" style={{backgroundColor: "${figma.colorString(child.backgroundColor)}"}}>\n`;
      nextSection += `      <C${child.name.replace(/\W+/g, '')} {...this.props} nodeId="${child.id}" />\n`;
      nextSection += '    </div>\n';
      nextSection += '  }\n';
      nextSection += '}\n\n';
    }
  }

  for (const key in componentMap) {
    const component = componentMap[key];
    const name = component.name;
  }
  contents += '\n';
  contents += nextSection;
  nextSection = '';

  contents += `export function getComponentFromId(id) {\n`;

  for (const key in componentMap) {
    contents += `  if (id === "${key}") return ${componentMap[key].instance};\n`;
    nextSection += componentMap[key].doc + '\n';
  }

  contents += '  return null;\n}\n\n';
  contents += nextSection;

  return contents;
}

(async () => {
  const file = args.file || './figma.json';
  const ref = args.ref || '.*';

  const file_content = JSON.parse(await fs.promises.readFile(file, 'utf8'));
  await Promise.all(Object.keys(file_content).filter((ref_)=>ref_.match(RegExp(ref))).map(async (ref_)=>{
    file_content[ref_].key = ref_;
    const contents = await pullFromFigma(file_content[ref_].figma_id, file_content[ref_]);
    await fs.promises.mkdir(path.dirname(file_content[ref_].output), {recursive: true});
    await fs.promises.writeFile(file_content[ref_].output, contents);
  }));

  // const figma_json = JSON.parse(fs.readFileSync(file, 'utf8').toString())
})().then(() => {
  exit(0);
}).catch((err) => {
  console.error(err);
  exit(err.exit_code || 1);
});
